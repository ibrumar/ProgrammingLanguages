\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{plcourse}
\usepackage{ttquot}
\usepackage{proof}
\usepackage{stmaryrd}
\usepackage{angle}
\usepackage{amssymb}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{tikz-qtree}
\usepackage{xspace}
\usepackage{floatflt,amsmath,amssymb}
\usepackage[ligature, inference]{semantic}

\homework{1}

\newcommand{\largestep}[1]{\rulename{#1${}_{\text{Lrg}}$}}

\begin{document}
\hwsubheader


% %%%%%%%%%%%%%%%%%%%%%%%%%%
%
%    Cover page
%
%
\vspace{5cm}
{\LARGE
\begin{tabular}{rp{0.6\linewidth}}
  Name:&\todo{Iulian Valentin Brumar}\\
  HUID:&\todo{PUT YOUR HUID HERE}\\
  Collaborators:&{\normalsize
    \todo{Put your collaborators here, if any.}
    }
\end{tabular}
}

\vfill
\textit{Make sure that the remaining pages of this assignment do not contain any identifying information.}
\vfill


% %%%%%%%%%%%%%%%%%%%%%%%%%%
%
%    Question 1
%
%

\newpage
\begin{question}{Semantics}{(25 points)}
 
 \newcommand{\fact}[1]{\lamfnt{fact}~#1}
 \newcommand{\modulo}[2]{#1~\lamfnt{mod}~#2}

%%   Here are some useful macros/code for this questions. Try uncommenting them to see what they do.
  \begin{subquestion}
   In this exercise we have to extend the small step semantics to handle the factorial. \\

   We need a rule that takes an expression to a new one. The $\sigma$ might change since another expression might be an assignment that changes the store. \\
   
   \infrule[FactExp]
           {
             <e, \sigma> \stepsone <e', \sigma'>
           }
           {
             <\fact{e}, \sigma> \stepsone <\fact{e'}, \sigma'>
           }
           {
           }

    We do not include a rule that takes factorial(e) to factorial(n) since there is already a rule that maps expressions to naturals and we have defined above what happens in the general case of mapping an expression onto another expression. Next, we define an axiom for the factorial when it is applied to a number.


   \infrule[Fact]
           {
             %<e, \sigma> \stepsone <n, \sigma'>
           }
           {
             <\fact{n}, \sigma> \stepsone <m, \sigma>
           }
           {
             where m is the factorial of n
           }

   \end{subquestion}
   \begin{subquestion}
   Extend the small step semantics to handle modulo expressions. \\

   The rules are defined similarly to how we dealt with the factorial, but now with two operands and having to define the order of evaluation. In order to match the large step semantics, we first evaluate the first operand of the modulo operation.

   \infrule[LMOD]
           {
             <e_1, \sigma> \stepsone <e_1', \sigma'>
           }
           {
             <\modulo{e_1}{e_2}, \sigma> \stepsone <\modulo{e_1'}{e_2}, \sigma''>
           }
           {
             %side condition
           }


   When the first operand is already an integer, we evaluate the second one.

   \infrule[RMOD]
           {
             <e_2, \sigma> \stepsone <e_2', \sigma'>
           }
           {
             <\modulo{n}{e_2}, \sigma> \stepsone <\modulo{n}{e_2'}, \sigma'>
           }
           {
             %where m is the factorial of n
           }


   When both operands are integers, the axiomatic rule is:

   \infrule[MOD]
           {
             %<e, \sigma> \stepsone <n, \sigma'>
           }
           {
             <\modulo{n}{m}, \sigma> \stepsone <k, \sigma>
           }
           {
             where k is n modulo m
           }
\end{subquestion}

\begin{subquestion}
What happens when we try to evaluate the expression $\modulo{(\fact{3})}{(-7)}$ having a store $\sigma_0$ that maps all the variables to 0.

Let us first use the large step semantics:

   \infrule[$MOD_{LRG}$]
           {
             %<e, \sigma> \stepsone <n, \sigma'>

             \infrule[$FACT_{LRG}$]
                     {
                        \infrule[$INT_{LRG}$]
                        {}
                        {<3, \sigma_0> \stepsone <3, \sigma_0>}
                     
                     }
                     {
                        <\fact{3}, \sigma_0> \stepsto <6, \sigma_0>
                     }  {}

             \infrule[$INT_{LRG}$]
                     {
                       %<3, \sigma> \stepsone <3, \sigma>
                     }
                     {
                       <-7, \sigma_0> \stepsto <-7, \sigma_0>
                     }
                     {}
           }
           {
             <\modulo{(\fact{3})}{(-7)}, \sigma_0> \stepsto <1, \sigma_0>
           }
           {
             where 1 is 6 mod -7
           }
    Since there is no assignment in the derivation tree, sigma stays the same.

    With the small step semantics the resulting derivations in order to prove that we can make the step $<\modulo{(\fact{3})}{(-7)}, \sigma_0> \stepsone <\modulo{(6)}{(-7)}, \sigma_0>$.


   \infrule[LMOD]
           {
             %<e, \sigma> \stepsone <n, \sigma'>

             \infrule[$Fact$]
                     {
                     }
                     {
                        <\fact{3}, \sigma_0> \stepsto <6, \sigma_0>
                     }  {}
           }
           {
             <\modulo{(\fact{3})}{(-7)}, \sigma_0> \stepsone<1, \sigma_0>
           }
           {
             %where 1 is 6 mod -7
           }

    Then to show that $<\modulo{(6)}{(-7)}, \sigma_0> \stepsone <1, \sigma_0>$.


   \infrule[MOD]
           {
             %<e, \sigma> \stepsone <n, \sigma'>
           }
           {
             <\modulo{(\fact{3})}{(-7)}, \sigma_0> \stepsone<1, \sigma_0>
           }
           {
             where 1 is 6 mod -7
           }

   In both cases the $\sigma_0$ does not influence any of the derivations since there are no variable assignments involved.

\end{subquestion}
%   \infrule[FactExp]
%           {
%             a_1 \in A \quad a_2 \in A
%           }
%           {
%             a \in A
%           }
%           {
%             side condition
%           }
 

%  An example of inference rule
%  \infrule[M]{  \infrule[N]{A \quad B}{C}{}  \quad D}{E}{} 


%    \[
%    <e, \sigma> \stepsone <e', \sigma'>
%    \]
%
%    \[
%    <e, \sigma> \stepsto <n, \sigma'>
%    \]
%
% \[
% e::= \dots \mid \fact{e} \mid \modulo{e_1}{e_2}
% \]

          
          
  
\end{question}

% %%%%%%%%%%%%%%%%%%%%%%%%%%
%
%    Question 2
%
%

\newpage
\begin{question}{Binary Trees and Induction}{(25 points)}
\newcommand{\tree}[3]{(#1,#2,#3)}
\newcommand{\TreeSet}{\Set{Tree}\xspace}
\newcommand{\SixTree}{\Set{SixTree}\xspace}
\newcommand{\ROOT}{\ensuremath{\mathit{root}}}
\newcommand{\rootf}[1]{\ROOT(#1)}

  
%%   Here are some useful macros/code for this questions. Try uncommenting them to see what they do.
%% $\rootf{\tree{4}{5}{6}}$

%% $t_1=$ \Tree [.5 [.7 [.-1 ] [.3 ] ] [.4 ] ] &

%% $t_1 \cong t_2$

%% \begin{itemize}
%% \item Case 1 where $e \equiv n$...
%% \item Case 2 where $e \equiv x$...
%% \end{itemize}

  
  %% Question 2a
  \begin{subquestion}
    \todo{Answer Question {\thesubquestion} here.}
  \end{subquestion}

  %% Question 2b
  \begin{subquestion}
    \todo{Answer Question {\thesubquestion} here.}
  \end{subquestion}

  %% Question 2c
  \begin{subquestion}
    \todo{Answer Question {\thesubquestion} here.}
  \end{subquestion}

  %% Question 2d
  \begin{subquestion} 
    
    \begin{subsubquestion}
    \todo{Answer Question {\thesubsubquestion} here.}      
    \end{subsubquestion}
    \begin{subsubquestion}
    \todo{Answer Question {\thesubsubquestion} here.}      
    \end{subsubquestion}
    \begin{subsubquestion}
    \todo{Answer Question {\thesubsubquestion} here.}      
    \end{subsubquestion}
  \end{subquestion}


  
  \begin{subquestion}
    \begin{subsubquestion}
    \todo{Answer Question {\thesubsubquestion} here.}      
    \end{subsubquestion}
    \begin{subsubquestion}
    \todo{Answer Question {\thesubsubquestion} here.}      
    \end{subsubquestion}
  \end{subquestion}
\end{question}

% %%%%%%%%%%%%%%%%%%%%%%%%%%
%
%    Question 3
%
%

\newpage
\begin{question}{Proof by Induction}{(25 points)}

%% Here are some useful macros/code for this questions. Try uncommenting them to see what they do.
%% $<e, \sigma> \stepsone^* <e',\sigma'> \stepsone^* <e'',\sigma''>$

  
  %% Question 3a
  \begin{subquestion}
  	 What is the inductive reasoning principle for the derivation of $<e, \sigma> \stepsone <e', \sigma'>$? Write it out in full.
  	 
  	 If
  	 \begin{itemize}
  	 \item $P(<x, \sigma> \stepsone <n, \sigma'>)$ with $x \in Var$ and $n \in \mathbb{Z}$.
   	 \item $P(<n+m, \sigma> \stepsone <p, \sigma'>)$ with $n,m,p \in \mathbb{Z}$ and p being the sum of n and m.
   	 \item $P(<n \times m, \sigma> \stepsone <p, \sigma'>)$ with $n,m,p \in \mathbb{Z}$ and p being the product of n and m.
   	 \item $P(<n \times m, \sigma> \stepsone <p, \sigma'>)$ with $n,m,p \in \mathbb{Z}$ and p being the product of n and m.
  	 %\item $P(<e, \sigma> \stepsone <x, \sigma'>)$ with $x \in Var$.
%  	 \item $P(<e, \sigma> \stepsone <n, \sigma'>)$ with $n \in \mathbb{Z}$.
   	 \item $\forall e_1, e_2 \in AExp$ if $P(<e_1, \sigma> \stepsone <e_1', \sigma'>)$ then $P(<e_1+e_2, \sigma> \stepsone <e_1'+e_2, \sigma'>)$.
   	 \item $\forall e_2 \in AExp$ and $, \forall n \in \mathbb{Z}$ if $P(<e_2, \sigma> \stepsone <e_2', \sigma'>)$ then $P(<n+e_2, \sigma> \stepsone <n+e_2', \sigma'>)$.
   	 \item $\forall e_1 \in AExp$ and $e_2 \in Aexp$ if $P(<e_1, \sigma> \stepsone <e_1', \sigma'>)$ and $P(<e_2, \sigma> \stepsone <e_2', \sigma'>)$ then $P(<e_1 \times e_2, \sigma> \stepsone <e_1' \times e_2', \sigma'>)$.
  	 \end{itemize}
   	 then $\forall <e, \sigma> \in Config, \exists <e', \sigma'> \in Config, P(<e, \sigma> \stepsone <e', \sigma'>)$.
  	 
  	
  \end{subquestion}

  %% Question 3b
  \begin{subquestion}
    For all $<e,\sigma> \stepsone <e',\sigma'>$, we will prove the property $P(<e,\sigma> \stepsone <e',\sigma'>) =$ If $<e, \sigma> \stepsone <e',\sigma'> and <e', \sigma'> \stepsto <n, \sigma'>$ then $<e, \sigma> \stepsto <n, \sigma'>$.
  \end{subquestion}

  %% Question 3c
  \begin{subquestion}
  	
  	 For each case mentioned in your inductive reasoning principle for $<e, \sigma> \stepsone <e', \sigma'>$, prove that case
  	holds for the property you stated above. 


\begin{itemize}
\item Case 1 where we have to show that $P(<e, \sigma> \stepsone <n, \sigma'>)$.

The full statement we need to prove is: if $<e, \sigma> \stepsone <n, \sigma''>)$ and $<n, \sigma''> \stepsto <n, \sigma'>)$ then $<e, \sigma> \stepsto <n, \sigma'>$.

%We can see that $\sigma = \sigma''$ since the only rules with the conclusion $<e, \sigma> \stepsone <n, \sigma''>$ are VAR, ADD and MUL. In all those cases the store does not change.

From $<n, \sigma''> \stepsto <n, \sigma'>)$ we find that $\sigma'' = \sigma'$. This is true since the only large step semantics rule with $<n, \sigma''> \stepsto <n, \sigma'>$ as a conclusion is $INT_{LRG}$ and in that rule the store does not change.

Since $\sigma'' = \sigma'$, we can transform the hypothesis $<e, \sigma> \stepsone <n, \sigma''>$ to $<e, \sigma> \stepsone <n, \sigma'>$. This implies that $<e, \sigma> \stepsone^* <n, \sigma'>$ and given that $<n, \sigma'>$ is a final configuration we conclude that $<e, \sigma> \stepsto <n, \sigma'>)$.



\item Case 2 where we have to show that $P(<e, \sigma> \stepsone <x, \sigma'>)$.

The argument proceeds similarly to Case 1.

%We can see that $\sigma = \sigma''$ since the only rules with the conclusion $<e, \sigma> \stepsone <n, \sigma''>$ are VAR, ADD and MUL. In all those cases the store does not change.

From $<x, \sigma''> \stepsto <n, \sigma'>)$ we deduce that $\sigma'' = \sigma'$. This is true since the only large step semantics rule with $<x, \sigma''> \stepsto <n, \sigma'>$ as a conclusion is $VAR_{LRG}$ having $\sigma'(x) = n$ and in that rule the store does not change.

Since $\sigma'' = \sigma'$, we can transform the hypothesis $<e, \sigma> \stepsone <x, \sigma''>$ to $<e, \sigma> \stepsone <x, \sigma'>$. From the previous step we also know that $\sigma'(x) = n$, meaning that $<x, \sigma'> \stepsto <n, \sigma'>$ according to the small step semantics axiom VAR.


Putting together the two small step semantics rules $<e, \sigma> \stepsone <x, \sigma'>$ and $<x, \sigma'> \stepsto <n, \sigma'>$ implies that $<e, \sigma> \stepsone^* <n, \sigma'>)$ and given that $<n, \sigma'>$ is a final configuration we conclude that $<e, \sigma> \stepsto <n, \sigma'>)$.

\item Case 3 \todo{We have to do the proof for the assignment as well}.

\item Case 4 where we have to show that $\forall e_1 \in AExp$ and $e_2 \in Aexp$ if $P(<e_1, \sigma> \stepsone <e_1', \sigma'>)$ and $P(<e_2, \sigma> \stepsone <e_2', \sigma'>)$ then $P(<e_1+e_2, \sigma> \stepsone <e_1'+e_2', \sigma'>)$.

We want to prove that if $<e_1+e_2, \sigma> \stepsone <e_1'+e_2', \sigma''>$ and $<e_1'+e_2', \sigma''> \stepsto <n, \sigma'>$ then $<e_1+e_2, \sigma''> \stepsto <n, \sigma'>$.

If $<e_1+e_2, \sigma> \stepsone <e_1'+e_2', \sigma''>$ it can only mean that 

By the inductive hypothesis we know that $<e_1, \sigma> \stepsone <e_1', \sigma''>$ and $<e_1', \sigma''> \stepsto <n_1, \sigma'>$ then $<e_1', \sigma''> \stepsto <n_1, \sigma'>$.

\item Case 5 \todo{Proof for addition with integer literal}.

\item Case 6 Multiplication \todo{This is almost copy paste of the addition}

\end{itemize}
    
  \end{subquestion}

\end{question}





% %%%%%%%%%%%%%%%%%%%%%%%%%%
%
%    Question 4
%
%

\newpage
\begin{question}{Stack-Oriented Programming}{(25 points)}

\newcommand{\push}[1]{\ensuremath{\mathbf{push}\;#1}}
\newcommand{\add}{\ensuremath{\mathbf{add}}}
\newcommand{\mul}{\ensuremath{\mathbf{mul}}}
\newcommand{\divcom}{\ensuremath{\mathbf{div}}}
\newcommand{\pop}{\ensuremath{\mathbf{pop}}}
\newcommand{\dup}{\ensuremath{\mathbf{dup}}}
\newcommand{\swap}[1]{\ensuremath{\mathbf{swap}\;{#1}}}
\newcommand{\seq}[2]{\ensuremath{#1; #2}}
\renewcommand{\skip}{\ensuremath{\mathbf{skip}}}
\newcommand{\WHILENE}{\ensuremath{\mathbf{whilene}}\xspace}
\newcommand{\whilene}[1]{\ensuremath{\WHILENE\;\{#1\}}}
\newcommand{\emptystack}{\ensuremath{[]}}
\newcommand{\stack}{\ensuremath{S}}
\newcommand{\cons}[2]{\ensuremath{#1 :: #2}}

%% Here are some useful macros/code for this questions. Try uncommenting them to see what they do.
% $<\push{3}; \pop; \whilene{\push{6};\push{7};\mul}, \stack>$

% $<\push{8},S> \stepsto \cons{8}{S}$


  \begin{subquestion}
    \begin{subsubquestion}
      Command $\push{n}$: 
      
      \infrule[PUSH]
      {
      	
      }
      {
      	<$\push n$, $\stack$> \stepsto $\cons{n}{S}$
      }
      {
      	%where m is the factorial of n
      }
    \end{subsubquestion}
    \begin{subsubquestion}
      Command $\pop$: No more inference rules to add.
    \end{subsubquestion}
    \begin{subsubquestion}
      Command $\add$:
      
      \infrule[ADD]
      {
      	
      }
      {
      	<$\add$, $\cons{\cons{n}{m}}{S}$> \stepsto $\cons{k}{S}$
      }
      {
      	where k is the sum of n and m.
      }
    \end{subsubquestion}
    \begin{subsubquestion}
      Command $\mul$: 
      
      \infrule[MUL]
      {
      	
      }
      {
      	<$\mul$, $\cons{\cons{n}{m}}{S}$> \stepsto $\cons{k}{S}$
      }
      {
      	where k is the multiplication of n and m.
      }
    \end{subsubquestion}
    \begin{subsubquestion}
      Command $\divcom$: No more inference rules to add.
    \end{subsubquestion}
    \begin{subsubquestion}
      Command $\dup$: 
      
      \infrule[DUP]
      {
      	
      }
      {
      	<$\dup$, $\cons{n}{S}$> \stepsto $\cons{n}{\cons{n}{S}}$
      }
      {
      	%where k is the multiplication of n and m.
      }
    \end{subsubquestion}
    \begin{subsubquestion}
      Command $\swap{i}$: No more inference rules to add.
    \end{subsubquestion}
    \begin{subsubquestion}
      Command $\seq{c_1}{c_2}$: No more inference rules to add.
    \end{subsubquestion}
    \begin{subsubquestion}
      Command $\whilene{c}$: 
      
      \infrule[WHILENE2]
      {
      	<$c, \cons{\cons{n_0}{n_1}}{S}$> \stepsto $\stack''$ <$\whilene{c}$, $\stack''$> \stepsto $\stack'$
      }
      {
      	<$\whilene{c}$, $\cons{n_0}{\cons{n_1}{S}}$> \stepsto $\stack'$
      }
      {
      	$n_0 \ne n_1$
      }
      
    \end{subsubquestion}
    \begin{subsubquestion}
      Command $\skip$: 
      
      \infrule[SKIP]
      {
      	
      }
      {
      	<$\skip$, $\stack$> \stepsto $\stack$
      }
      {
      	%where k is the multiplication of n and m.
      }
    \end{subsubquestion}

  \end{subquestion}

  % Question 4b
  \begin{subquestion}
    \todo{this still needs to be done}.
  \end{subquestion}
  
  % Question 4c
  \begin{subquestion}
 Write a program in our toy language that takes as input a stack of the form n :: [] where $n \geq 0$ and
finishes with a stack of the form 0 :: 1 :: 2 :: \dots :: n :: []. Briefly describe (in words) how your
implementation works. (That is, help the grader understand why your code is correct!)

The program we propose is:\\
 \emph{push 0; whilene \{ pop; dup; push -1; add; push 0 \}; pop}
 
 The idea is to keep a 0 on top of the stack before checking the condition of the while command, and to leave the number i+1 just underneath the top element (0) so that we can remember at each iteration to leave the element i (also under the top which should be 0).
 
 The reason for leaving a 0 on top of the stack is because the algorithm must finish when the i'th element we have to compute is 0. The reason why we do a dup at the beginning of each iteration just before the pop of the top 0 value, is because we do not want to lose the i+1 value when computing the sum: we just want to subtract 1 from it for the current iteration.
 
 Obviously before finishing the program there is a redundant zero on top of the stack which we eliminate with a pop. 


  \end{subquestion}
  
  % Question 4d
  \begin{subquestion}
    Write a program in our toy language that takes as input a stack of the form n :: [] where $n \geq 0$ and
   finishes with a stack of the form n :: (n - 1) :: \dots :: 1 :: 0 :: []. Briefly describe (in words) how your
   implementation works. (That is, help the grader understand why your code is correct!)
   
   The implementation we propose is:
   
   \emph{push 0; whilene \{ dup; push 1; add; swap 1; swap 2; swap 1 \}; pop}.
   
   We first push on top of the stack a 0 and in general, before checking whilene's condition, we guarantee that on top of the stack there is the value i-1 computed during the previous iteration and the second element is n so that the loop stops when i-1 is n.
   
   Guaranteeing this ordering of the values i-1 as the top element and of n as the second requires the manipulation with the three swaps we have in whilene's loop body. The first three instructions in the loop body leave us with i, i-1 and n on top of the stack. The first swap changes the order to i-1, i and n; the second swap to n, i, i-1 and the last swap to i, n, i-1. If n turns out to be equal to n, the loop will stop and we have to pop a redundant n value on top.
    
  \end{subquestion}
  
  
  
  % Question 4e
  \begin{subquestion}
     Write a program that takes as input a stack of the form m :: n :: [] where $m \gt 0$ and $n \gt 0$ and finishes
    with a stack of the form i :: [], where i is 0 if m is a multiple of n, and 1 otherwise. Briefly describe
    (in words) how your implementation works. (That is, help the grader understand why your code is
    correct!).
    
    The solution we propose is:
    
    \emph{dup; swap 2; dup; swap 2; div; mul; div; ; push -1; mul; push 1; add}.
    
    The program is divided in two parts. The last div outputs a 1 if m is a multiple of n and a 0 if it is not. The next 4 instructions just invert 0 for a 1 and 1 for a 0.
    
    In the first four instructions before the first division leave the stack in a format of m :: n :: n :: m. The reason for this is that we first want to divide m by n to produce q. We know that if we multiply q by n the result is smaller or equal to m. If it is not equal, it means that m is not divisible by n. The next step is to divide n*q by m. If the result is one it means that they were equal but the integer division will return zero otherwise.
    
    In the second part in order to invert the result 'p' in the previous paragraph , we change its sign (by multiplying with -1) and add one to that. If p was 0, changing the sign has no effect and by adding one, the overall result is one. If p was 1, changing the sign results in -1 and adding 1 to that gives 0.
    
    
  \end{subquestion}
  
    
\end{question}



\end{document}
